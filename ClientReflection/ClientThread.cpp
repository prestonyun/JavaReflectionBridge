#include "ClientThread.hpp"

ClientThread::ClientThread(JNIEnv* env) {
    this->env = env;
    clientThreadClass = env->FindClass("net/runelite/client/callback/ClientThread");
    jclass runeLiteClass = env->FindClass("net/runelite/client/RuneLite");
    jfieldID injectorField = env->GetStaticFieldID(runeLiteClass, "injector", "Lcom/google/inject/Injector;");
    injector = env->GetStaticObjectField(runeLiteClass, injectorField);
    jclass injectorClass = env->GetObjectClass(injector)
    jmethodID getInstanceMethod = env->GetMethodID(injectorClass, "getInstance", "(Ljava/lang/Class;)Ljava/lang/Object;");
    clientThread = env->CallObjectMethod(injector, getInstanceMethod, clientThreadClass);
}

ClientThread::ClientThread(JNIEnv* env, jobject client) {
    this->env = env;
    clientThreadClass = env->FindClass("net/runelite/client/callback/ClientThread");
    jmethodID getClientThreadMethod = env->GetMethodID(clientThreadClass, "getClientThread", "()Lnet/runelite/client/callback/ClientThread;");
    clientThread = env->CallObjectMethod(client, getClientThreadMethod);
    jmethodID invoke = env->GetMethodID(clientThreadClass, "invoke", "(Ljava/lang/Runnable;)V");
}

ClientThread::~ClientThread() {
    env->DeleteLocalRef(clientThreadClass);
    env->DeleteLocalRef(clientThread);
}

jobject ClientThread::createJavaRunnable(JNIEnv* env, std::function<void()> task) {
    currentTask = std::move(task);

    // Find the java.lang.Runnable class
    jclass runnableClass = env->FindClass("java/lang/Runnable");

    // Generate the bytecode for the dynamic proxy
    std::string bytecode = "...";  // This will be the bytecode for a class that implements Runnable and has its run method call back into the C++ function

    // Load the generated bytecode into the JVM
    jclass loaderClass = env->FindClass("java/lang/ClassLoader");
    jmethodID defineClassMethod = env->GetMethodID(loaderClass, "defineClass", "(Ljava/lang/String;[BII)Ljava/lang/Class;");
    jbyteArray bytecodeArray = env->NewByteArray(bytecode.size());
    env->SetByteArrayRegion(bytecodeArray, 0, bytecode.size(), reinterpret_cast<const jbyte*>(bytecode.data()));
    jclass proxyClass = static_cast<jclass>(env->CallObjectMethod(loaderClass, defineClassMethod, env->NewStringUTF("CallbackRunnable"), bytecodeArray, 0, bytecode.size()));
    env->DeleteLocalRef(bytecodeArray);

    // Instantiate the dynamic proxy class
    jmethodID ctor = env->GetMethodID(proxyClass, "<init>", "()V");
    jobject runnableInstance = env->NewObject(proxyClass, ctor);

    return runnableInstance;
}

void ClientThread::invokeOnClientThread(std::function<void()> task) {
    jobject runnable = createRunnable(task);
    
    if (!invokeMethod) {
        invokeMethod = env->GetMethodID(clientThreadClass, "invoke", "(Ljava/lang/Runnable;)V");
    }
    env->CallVoidMethod(clientThread, invokeMethod, runnable);

    env->DeleteLocalRef(runnable);
}

jobject ClientThread::createRunnable(std::function<void()> task) {
    currentTask = task;
    
    // Create a new Runnable using an anonymous subclass
    std::string runnableCode = "(Ljava/lang/Object;)Ljava/lang/Runnable;";
    jmethodID ctor = env->GetMethodID(clientThreadClass, "<init>", "()V");
    jobject newRunnable = env->NewObject(clientThreadClass, ctor);
    return newRunnable;
}